/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assign = require('object-assign');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var React = require('./React');
var ReactTransitionChildMapping = require('./ReactTransitionChildMapping');

var emptyFunction = require('fbjs/lib/emptyFunction');

/**
 * A basis for animations. When children are declaratively added or removed,
 * special lifecycle hooks are called.
 * See https://facebook.github.io/react/docs/animation.html#low-level-api-reacttransitiongroup
 */

var ReactTransitionGroup = function (_React$Component) {
  _inherits(ReactTransitionGroup, _React$Component);

  function ReactTransitionGroup() {
    var _temp, _this, _ret;

    _classCallCheck(this, ReactTransitionGroup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      // TODO: can we get useful debug information to show at this point?
      children: ReactTransitionChildMapping.getChildMapping(_this.props.children)
    }, _this.performAppear = function (key) {
      _this.currentlyTransitioningKeys[key] = true;

      var component = _this.refs[key];

      if (component.componentWillAppear) {
        component.componentWillAppear(_this._handleDoneAppearing.bind(_this, key));
      } else {
        _this._handleDoneAppearing(key);
      }
    }, _this._handleDoneAppearing = function (key) {
      var component = _this.refs[key];
      if (component.componentDidAppear) {
        component.componentDidAppear();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = ReactTransitionChildMapping.getChildMapping(_this.props.children);

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully appeared. Remove it.
        _this.performLeave(key);
      }
    }, _this.performEnter = function (key) {
      _this.currentlyTransitioningKeys[key] = true;

      var component = _this.refs[key];

      if (component.componentWillEnter) {
        component.componentWillEnter(_this._handleDoneEntering.bind(_this, key));
      } else {
        _this._handleDoneEntering(key);
      }
    }, _this._handleDoneEntering = function (key) {
      var component = _this.refs[key];
      if (component.componentDidEnter) {
        component.componentDidEnter();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = ReactTransitionChildMapping.getChildMapping(_this.props.children);

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully entered. Remove it.
        _this.performLeave(key);
      }
    }, _this.performLeave = function (key) {
      _this.currentlyTransitioningKeys[key] = true;

      var component = _this.refs[key];
      if (component.componentWillLeave) {
        component.componentWillLeave(_this._handleDoneLeaving.bind(_this, key));
      } else {
        // Note that this is somewhat dangerous b/c it calls setState()
        // again, effectively mutating the component before all the work
        // is done.
        _this._handleDoneLeaving(key);
      }
    }, _this._handleDoneLeaving = function (key) {
      var component = _this.refs[key];

      if (component.componentDidLeave) {
        component.componentDidLeave();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = ReactTransitionChildMapping.getChildMapping(_this.props.children);

      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
        // This entered again before it fully left. Add it again.
        _this.performEnter(key);
      } else {
        _this.setState(function (state) {
          var newChildren = _assign({}, state.children);
          delete newChildren[key];
          return { children: newChildren };
        });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  ReactTransitionGroup.prototype.componentWillMount = function componentWillMount() {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  };

  ReactTransitionGroup.prototype.componentDidMount = function componentDidMount() {
    var initialChildMapping = this.state.children;
    for (var key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  };

  ReactTransitionGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  };

  ReactTransitionGroup.prototype.componentDidUpdate = function componentDidUpdate() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  };

  ReactTransitionGroup.prototype.render = function render() {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender.push(React.cloneElement(this.props.childFactory(child), { ref: key, key: key }));
      }
    }

    // Do not forward ReactTransitionGroup props to primitive DOM nodes
    var props = _assign({}, this.props);
    delete props.transitionLeave;
    delete props.transitionName;
    delete props.transitionAppear;
    delete props.transitionEnter;
    delete props.childFactory;
    delete props.transitionLeaveTimeout;
    delete props.transitionEnterTimeout;
    delete props.transitionAppearTimeout;
    delete props.component;

    return React.createElement(this.props.component, props, childrenToRender);
  };

  return ReactTransitionGroup;
}(React.Component);

ReactTransitionGroup.displayName = 'ReactTransitionGroup';
ReactTransitionGroup.propTypes = {
  component: React.PropTypes.any,
  childFactory: React.PropTypes.func
};
ReactTransitionGroup.defaultProps = {
  component: 'span',
  childFactory: emptyFunction.thatReturnsArgument
};

module.exports = ReactTransitionGroup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3B1YmxpYy9saWIvcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkdyb3VwLmpzIl0sIm5hbWVzIjpbIl9hc3NpZ24iLCJyZXF1aXJlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsImNhbGwiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIlJlYWN0IiwiUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nIiwiZW1wdHlGdW5jdGlvbiIsIlJlYWN0VHJhbnNpdGlvbkdyb3VwIiwiX1JlYWN0JENvbXBvbmVudCIsIl90ZW1wIiwiX3RoaXMiLCJfcmV0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImNvbmNhdCIsInN0YXRlIiwiY2hpbGRyZW4iLCJnZXRDaGlsZE1hcHBpbmciLCJwcm9wcyIsInBlcmZvcm1BcHBlYXIiLCJrZXkiLCJjdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5cyIsImNvbXBvbmVudCIsInJlZnMiLCJjb21wb25lbnRXaWxsQXBwZWFyIiwiX2hhbmRsZURvbmVBcHBlYXJpbmciLCJiaW5kIiwiY29tcG9uZW50RGlkQXBwZWFyIiwiY3VycmVudENoaWxkTWFwcGluZyIsImhhc093blByb3BlcnR5IiwicGVyZm9ybUxlYXZlIiwicGVyZm9ybUVudGVyIiwiY29tcG9uZW50V2lsbEVudGVyIiwiX2hhbmRsZURvbmVFbnRlcmluZyIsImNvbXBvbmVudERpZEVudGVyIiwiY29tcG9uZW50V2lsbExlYXZlIiwiX2hhbmRsZURvbmVMZWF2aW5nIiwiY29tcG9uZW50RGlkTGVhdmUiLCJzZXRTdGF0ZSIsIm5ld0NoaWxkcmVuIiwiY29tcG9uZW50V2lsbE1vdW50Iiwia2V5c1RvRW50ZXIiLCJrZXlzVG9MZWF2ZSIsImNvbXBvbmVudERpZE1vdW50IiwiaW5pdGlhbENoaWxkTWFwcGluZyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0UHJvcHMiLCJuZXh0Q2hpbGRNYXBwaW5nIiwicHJldkNoaWxkTWFwcGluZyIsIm1lcmdlQ2hpbGRNYXBwaW5ncyIsImhhc1ByZXYiLCJwdXNoIiwiaGFzTmV4dCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImZvckVhY2giLCJyZW5kZXIiLCJjaGlsZHJlblRvUmVuZGVyIiwiY2hpbGQiLCJjbG9uZUVsZW1lbnQiLCJjaGlsZEZhY3RvcnkiLCJyZWYiLCJ0cmFuc2l0aW9uTGVhdmUiLCJ0cmFuc2l0aW9uTmFtZSIsInRyYW5zaXRpb25BcHBlYXIiLCJ0cmFuc2l0aW9uRW50ZXIiLCJ0cmFuc2l0aW9uTGVhdmVUaW1lb3V0IiwidHJhbnNpdGlvbkVudGVyVGltZW91dCIsInRyYW5zaXRpb25BcHBlYXJUaW1lb3V0IiwiY3JlYXRlRWxlbWVudCIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiYW55IiwiZnVuYyIsImRlZmF1bHRQcm9wcyIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVVBOzs7O0FBRUEsSUFBSUEsVUFBVUMsUUFBUSxlQUFSLENBQWQ7O0FBRUEsU0FBU0MsZUFBVCxDQUF5QkMsUUFBekIsRUFBbUNDLFdBQW5DLEVBQWdEO0FBQUUsTUFBSSxFQUFFRCxvQkFBb0JDLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLFNBQVND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LEdBQWlCNUUsb0JBQWpCIiwiZmlsZSI6IlJlYWN0VHJhbnNpdGlvbkdyb3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgnLi9SZWFjdCcpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZyA9IHJlcXVpcmUoJy4vUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIEEgYmFzaXMgZm9yIGFuaW1hdGlvbnMuIFdoZW4gY2hpbGRyZW4gYXJlIGRlY2xhcmF0aXZlbHkgYWRkZWQgb3IgcmVtb3ZlZCxcbiAqIHNwZWNpYWwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjYWxsZWQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9hbmltYXRpb24uaHRtbCNsb3ctbGV2ZWwtYXBpLXJlYWN0dHJhbnNpdGlvbmdyb3VwXG4gKi9cblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlYWN0VHJhbnNpdGlvbkdyb3VwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZWFjdFRyYW5zaXRpb25Hcm91cCgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0VHJhbnNpdGlvbkdyb3VwKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFRPRE86IGNhbiB3ZSBnZXQgdXNlZnVsIGRlYnVnIGluZm9ybWF0aW9uIHRvIHNob3cgYXQgdGhpcyBwb2ludD9cbiAgICAgIGNoaWxkcmVuOiBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKF90aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgIH0sIF90aGlzLnBlcmZvcm1BcHBlYXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLnJlZnNba2V5XTtcblxuICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsQXBwZWFyKSB7XG4gICAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsQXBwZWFyKF90aGlzLl9oYW5kbGVEb25lQXBwZWFyaW5nLmJpbmQoX3RoaXMsIGtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX2hhbmRsZURvbmVBcHBlYXJpbmcoa2V5KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5faGFuZGxlRG9uZUFwcGVhcmluZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5yZWZzW2tleV07XG4gICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZEFwcGVhcikge1xuICAgICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkQXBwZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBfdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoX3RoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIWN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgYXBwZWFyZWQuIFJlbW92ZSBpdC5cbiAgICAgICAgX3RoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMucGVyZm9ybUVudGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgX3RoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5yZWZzW2tleV07XG5cbiAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbEVudGVyKSB7XG4gICAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsRW50ZXIoX3RoaXMuX2hhbmRsZURvbmVFbnRlcmluZy5iaW5kKF90aGlzLCBrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9oYW5kbGVEb25lRW50ZXJpbmcoa2V5KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5faGFuZGxlRG9uZUVudGVyaW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLnJlZnNba2V5XTtcbiAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkRW50ZXIpIHtcbiAgICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBfdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoX3RoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIWN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgZW50ZXJlZC4gUmVtb3ZlIGl0LlxuICAgICAgICBfdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5wZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLnJlZnNba2V5XTtcbiAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbExlYXZlKSB7XG4gICAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUoX3RoaXMuX2hhbmRsZURvbmVMZWF2aW5nLmJpbmQoX3RoaXMsIGtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgc29tZXdoYXQgZGFuZ2Vyb3VzIGIvYyBpdCBjYWxscyBzZXRTdGF0ZSgpXG4gICAgICAgIC8vIGFnYWluLCBlZmZlY3RpdmVseSBtdXRhdGluZyB0aGUgY29tcG9uZW50IGJlZm9yZSBhbGwgdGhlIHdvcmtcbiAgICAgICAgLy8gaXMgZG9uZS5cbiAgICAgICAgX3RoaXMuX2hhbmRsZURvbmVMZWF2aW5nKGtleSk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuX2hhbmRsZURvbmVMZWF2aW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLnJlZnNba2V5XTtcblxuICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRMZWF2ZSkge1xuICAgICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkTGVhdmUoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIF90aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cbiAgICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyhfdGhpcy5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChjdXJyZW50Q2hpbGRNYXBwaW5nICYmIGN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAvLyBUaGlzIGVudGVyZWQgYWdhaW4gYmVmb3JlIGl0IGZ1bGx5IGxlZnQuIEFkZCBpdCBhZ2Fpbi5cbiAgICAgICAgX3RoaXMucGVyZm9ybUVudGVyKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBfYXNzaWduKHt9LCBzdGF0ZS5jaGlsZHJlbik7XG4gICAgICAgICAgZGVsZXRlIG5ld0NoaWxkcmVuW2tleV07XG4gICAgICAgICAgcmV0dXJuIHsgY2hpbGRyZW46IG5ld0NoaWxkcmVuIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUmVhY3RUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzID0ge307XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgfTtcblxuICBSZWFjdFRyYW5zaXRpb25Hcm91cC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgaW5pdGlhbENoaWxkTWFwcGluZyA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG4gICAgZm9yICh2YXIga2V5IGluIGluaXRpYWxDaGlsZE1hcHBpbmcpIHtcbiAgICAgIGlmIChpbml0aWFsQ2hpbGRNYXBwaW5nW2tleV0pIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQXBwZWFyKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0VHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcobmV4dFByb3BzLmNoaWxkcmVuKTtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoaWxkcmVuOiBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcubWVyZ2VDaGlsZE1hcHBpbmdzKHByZXZDaGlsZE1hcHBpbmcsIG5leHRDaGlsZE1hcHBpbmcpXG4gICAgfSk7XG5cbiAgICB2YXIga2V5O1xuXG4gICAgZm9yIChrZXkgaW4gbmV4dENoaWxkTWFwcGluZykge1xuICAgICAgdmFyIGhhc1ByZXYgPSBwcmV2Q2hpbGRNYXBwaW5nICYmIHByZXZDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChuZXh0Q2hpbGRNYXBwaW5nW2tleV0gJiYgIWhhc1ByZXYgJiYgIXRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuICAgICAgICB0aGlzLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBwcmV2Q2hpbGRNYXBwaW5nKSB7XG4gICAgICB2YXIgaGFzTmV4dCA9IG5leHRDaGlsZE1hcHBpbmcgJiYgbmV4dENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKHByZXZDaGlsZE1hcHBpbmdba2V5XSAmJiAhaGFzTmV4dCAmJiAhdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgIHRoaXMua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIHdhbnQgdG8gc29tZWRheSBjaGVjayBmb3IgcmVvcmRlcmluZywgd2UgY291bGQgZG8gaXQgaGVyZS5cbiAgfTtcblxuICBSZWFjdFRyYW5zaXRpb25Hcm91cC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIGtleXNUb0VudGVyLmZvckVhY2godGhpcy5wZXJmb3JtRW50ZXIpO1xuXG4gICAgdmFyIGtleXNUb0xlYXZlID0gdGhpcy5rZXlzVG9MZWF2ZTtcbiAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAga2V5c1RvTGVhdmUuZm9yRWFjaCh0aGlzLnBlcmZvcm1MZWF2ZSk7XG4gIH07XG5cbiAgUmVhY3RUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAvLyBUT0RPOiB3ZSBjb3VsZCBnZXQgcmlkIG9mIHRoZSBuZWVkIGZvciB0aGUgd3JhcHBlciBub2RlXG4gICAgLy8gYnkgY2xvbmluZyBhIHNpbmdsZSBjaGlsZFxuICAgIHZhciBjaGlsZHJlblRvUmVuZGVyID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdGUuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuc3RhdGUuY2hpbGRyZW5ba2V5XTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAvLyBZb3UgbWF5IG5lZWQgdG8gYXBwbHkgcmVhY3RpdmUgdXBkYXRlcyB0byBhIGNoaWxkIGFzIGl0IGlzIGxlYXZpbmcuXG4gICAgICAgIC8vIFRoZSBub3JtYWwgUmVhY3Qgd2F5IHRvIGRvIGl0IHdvbid0IHdvcmsgc2luY2UgdGhlIGNoaWxkIHdpbGwgaGF2ZVxuICAgICAgICAvLyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC4gSW4gY2FzZSB5b3UgbmVlZCB0aGlzIGJlaGF2aW9yIHlvdSBjYW4gcHJvdmlkZVxuICAgICAgICAvLyBhIGNoaWxkRmFjdG9yeSBmdW5jdGlvbiB0byB3cmFwIGV2ZXJ5IGNoaWxkLCBldmVuIHRoZSBvbmVzIHRoYXQgYXJlXG4gICAgICAgIC8vIGxlYXZpbmcuXG4gICAgICAgIGNoaWxkcmVuVG9SZW5kZXIucHVzaChSZWFjdC5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5jaGlsZEZhY3RvcnkoY2hpbGQpLCB7IHJlZjoga2V5LCBrZXk6IGtleSB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGZvcndhcmQgUmVhY3RUcmFuc2l0aW9uR3JvdXAgcHJvcHMgdG8gcHJpbWl0aXZlIERPTSBub2Rlc1xuICAgIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuICAgIGRlbGV0ZSBwcm9wcy50cmFuc2l0aW9uTGVhdmU7XG4gICAgZGVsZXRlIHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIGRlbGV0ZSBwcm9wcy50cmFuc2l0aW9uQXBwZWFyO1xuICAgIGRlbGV0ZSBwcm9wcy50cmFuc2l0aW9uRW50ZXI7XG4gICAgZGVsZXRlIHByb3BzLmNoaWxkRmFjdG9yeTtcbiAgICBkZWxldGUgcHJvcHMudHJhbnNpdGlvbkxlYXZlVGltZW91dDtcbiAgICBkZWxldGUgcHJvcHMudHJhbnNpdGlvbkVudGVyVGltZW91dDtcbiAgICBkZWxldGUgcHJvcHMudHJhbnNpdGlvbkFwcGVhclRpbWVvdXQ7XG4gICAgZGVsZXRlIHByb3BzLmNvbXBvbmVudDtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY29tcG9uZW50LCBwcm9wcywgY2hpbGRyZW5Ub1JlbmRlcik7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0VHJhbnNpdGlvbkdyb3VwO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWFjdFRyYW5zaXRpb25Hcm91cC5kaXNwbGF5TmFtZSA9ICdSZWFjdFRyYW5zaXRpb25Hcm91cCc7XG5SZWFjdFRyYW5zaXRpb25Hcm91cC5wcm9wVHlwZXMgPSB7XG4gIGNvbXBvbmVudDogUmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgY2hpbGRGYWN0b3J5OiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblJlYWN0VHJhbnNpdGlvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50OiAnc3BhbicsXG4gIGNoaWxkRmFjdG9yeTogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uR3JvdXA7Il19