/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ReactTypeOfWork = require('./ReactTypeOfWork');
var IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,
    ClassComponent = ReactTypeOfWork.ClassComponent,
    HostContainer = ReactTypeOfWork.HostContainer,
    HostComponent = ReactTypeOfWork.HostComponent,
    CoroutineComponent = ReactTypeOfWork.CoroutineComponent,
    YieldComponent = ReactTypeOfWork.YieldComponent;

var _require = require('./ReactPriorityLevel'),
    NoWork = _require.NoWork;

// An Instance is shared between all versions of a component. We can easily
// break this out into a separate object to avoid copying so much to the
// alternate versions of the tree. We put this on a single object for now to
// minimize the number of objects created during the initial render.


// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


// This is a constructor of a POJO instead of a constructor function for a few
// reasons:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We can easily go from a createFiber call to calling a constructor if that
//    is faster. The opposite is not true.
// 4) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function createFiber(tag, key) {
  return {

    // Instance

    tag: tag,

    key: key,

    type: null,

    stateNode: null,

    // Fiber

    'return': null,

    child: null,
    sibling: null,

    ref: null,

    pendingProps: null,
    memoizedProps: null,
    updateQueue: null,
    memoizedState: null,
    callbackList: null,
    output: null,

    nextEffect: null,
    firstEffect: null,
    lastEffect: null,

    pendingWorkPriority: NoWork,
    progressedPriority: NoWork,
    progressedChild: null,

    alternate: null

  };
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
// TODO: Rename to createWorkInProgressFiber or something like that.
exports.cloneFiber = function (fiber, priorityLevel) {
  // We clone to get a work in progress. That means that this fiber is the
  // current. To make it safe to reuse that fiber later on as work in progress
  // we need to reset its work in progress flag now. We don't have an
  // opportunity to do this earlier since we don't traverse the tree when
  // the work in progress tree becomes the current tree.
  // fiber.progressedPriority = NoWork;
  // fiber.progressedChild = null;

  // We use a double buffering pooling technique because we know that we'll only
  // ever need at most two versions of a tree. We pool the "other" unused node
  // that we're free to reuse. This is lazily created to avoid allocating extra
  // objects for things that are never updated. It also allow us to reclaim the
  // extra memory if needed.
  var alt = fiber.alternate;
  if (alt) {
    // Whenever we clone, we do so to get a new work in progress.
    // This ensures that we've reset these in the new tree.
    alt.nextEffect = null;
    alt.firstEffect = null;
    alt.lastEffect = null;
  } else {
    // This should not have an alternate already
    alt = createFiber(fiber.tag, fiber.key);
    alt.type = fiber.type;

    alt.progressedChild = fiber.progressedChild;
    alt.progressedPriority = fiber.progressedPriority;

    alt.alternate = fiber;
    fiber.alternate = alt;
  }

  alt.stateNode = fiber.stateNode;
  alt.child = fiber.child;
  alt.sibling = fiber.sibling; // This should always be overridden. TODO: null
  alt.ref = fiber.ref;
  // pendingProps is here for symmetry but is unnecessary in practice for now.
  // TODO: Pass in the new pendingProps as an argument maybe?
  alt.pendingProps = fiber.pendingProps;
  alt.updateQueue = fiber.updateQueue;
  alt.callbackList = fiber.callbackList;
  alt.pendingWorkPriority = priorityLevel;

  alt.memoizedProps = fiber.memoizedProps;
  alt.output = fiber.output;

  return alt;
};

exports.createHostContainerFiber = function () {
  var fiber = createFiber(HostContainer, null);
  return fiber;
};

exports.createFiberFromElement = function (element, priorityLevel) {
  // $FlowFixMe: ReactElement.key is currently defined as ?string but should be defined as null | string in Flow.
  var fiber = createFiberFromElementType(element.type, element.key);
  fiber.pendingProps = element.props;
  fiber.pendingWorkPriority = priorityLevel;
  return fiber;
};

function createFiberFromElementType(type, key) {
  var fiber = void 0;
  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key) : createFiber(IndeterminateComponent, key);
    fiber.type = type;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key);
    fiber.type = type;
  } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null) {
    // Currently assumed to be a continuation and therefore is a fiber already.
    fiber = type;
  } else {
    throw new Error('Unknown component type: ' + (typeof type === 'undefined' ? 'undefined' : _typeof(type)));
  }
  return fiber;
}

exports.createFiberFromElementType = createFiberFromElementType;

exports.createFiberFromCoroutine = function (coroutine, priorityLevel) {
  var fiber = createFiber(CoroutineComponent, coroutine.key);
  fiber.type = coroutine.handler;
  fiber.pendingProps = coroutine;
  fiber.pendingWorkPriority = priorityLevel;
  return fiber;
};

exports.createFiberFromYield = function (yieldNode, priorityLevel) {
  var fiber = createFiber(YieldComponent, yieldNode.key);
  fiber.pendingProps = {};
  return fiber;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3B1YmxpYy9saWIvcmVhY3QtZG9tL2xpYi9SZWFjdEZpYmVyLmpzIl0sIm5hbWVzIjpbIlJlYWN0VHlwZU9mV29yayIsInJlcXVpcmUiLCJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJIb3N0Q29udGFpbmVyIiwiSG9zdENvbXBvbmVudCIsIkNvcm91dGluZUNvbXBvbmVudCIsIllpZWxkQ29tcG9uZW50IiwiX3JlcXVpcmUiLCJOb1dvcmsiLCJjcmVhdGVGaWJlciIsInRhZyIsImtleSIsInR5cGUiLCJzdGF0ZU5vZGUiLCJjaGlsZCIsInNpYmxpbmciLCJyZWYiLCJwZW5kaW5nUHJvcHMiLCJtZW1vaXplZFByb3BzIiwidXBkYXRlUXVldWUiLCJtZW1vaXplZFN0YXRlIiwiY2FsbGJhY2tMaXN0Iiwib3V0cHV0IiwibmV4dEVmZmVjdCIsImZpcnN0RWZmZWN0IiwibGFzdEVmZmVjdCIsInBlbmRpbmdXb3JrUHJpb3JpdHkiLCJwcm9ncmVzc2VkUHJpb3JpdHkiLCJwcm9ncmVzc2VkQ2hpbGQiLCJhbHRlcm5hdGUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiZXhwb3J0cyIsImNsb25lRmliZXIiLCJmaWJlciIsInByaW9yaXR5TGV2ZWwiLCJhbHQiLCJjcmVhdGVIb3N0Q29udGFpbmVyRmliZXIiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwiZWxlbWVudCIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnRUeXBlIiwicHJvcHMiLCJFcnJvciIsImNyZWF0ZUZpYmVyRnJvbUNvcm91dGluZSIsImNvcm91dGluZSIsImhhbmRsZXIiLCJjcmVhdGVGaWJlckZyb21ZaWVsZCIsInlpZWxkTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7QUFFQSxJQUFJQSxrQkFBa0JDLFFBQVEsbUJBQVIsQ0FBdEI7QUFDQSxJ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QSxTQUFTLElBQXpDLEVBQStDO0FBQ3BEO0FBQ0F3QixZQUFReEIsSUFBUjtBQUNELEdBSE0sTUFHQTtBQUNMLFVBQU0sSUFBSWdDLEtBQUosQ0FBVSxxQ0FBb0NoQyxJQUFwQyx5Q0FBb0NBLElBQXBDLEVBQVYsQ0FBTjtBQUNEO0FBQ0QsU0FBT3dCLEtBQVA7QUFDRDs7QUFFREYsUUFBUVEsMEJBQVIsR0FBcUNBLDBCQUFyQzs7QUFFQVIsUUFBUVcsd0JBQVIsR0FBbUMsVUFBVUMsU0FBVixFQUFxQlQsYUFBckIsRUFBb0M7QUFDckUsTUFBSUQsUUFBUTNCLFlBQVlKLGtCQUFaLEVBQWdDeUMsVUFBVW5DLEdBQTFDLENBQVo7QUFDQXlCLFFBQU14QixJQUFOLEdBQWFrQyxVQUFVQyxPQUF2QjtBQUNBWCxRQUFNbkIsWUFBTixHQUFxQjZCLFNBQXJCO0FBQ0FWLFFBQU1WLG1CQUFOLEdBQTRCVyxhQUE1QjtBQUNBLFNBQU9ELEtBQVA7QUFDRCxDQU5EOztBQVFBRixRQUFRYyxvQkFBUixHQUErQixVQUFVQyxTQUFWLEVBQXFCWixhQUFyQixFQUFvQztBQUNqRSxNQUFJRCxRQUFRM0IsWUFBWUgsY0FBWixFQUE0QjJDLFVBQVV0QyxHQUF0QyxDQUFaO0FBQ0F5QixRQUFNbkIsWUFBTixHQUFxQixFQUFyQjtBQUNBLFNBQU9tQixLQUFQO0FBQ0QsQ0FKRCIsImZpbGUiOiJSZWFjdEZpYmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RUeXBlT2ZXb3JrID0gcmVxdWlyZSgnLi9SZWFjdFR5cGVPZldvcmsnKTtcbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgQ2xhc3NDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuQ2xhc3NDb21wb25lbnQsXG4gICAgSG9zdENvbnRhaW5lciA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Q29udGFpbmVyLFxuICAgIEhvc3RDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuSG9zdENvbXBvbmVudCxcbiAgICBDb3JvdXRpbmVDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuQ29yb3V0aW5lQ29tcG9uZW50LFxuICAgIFlpZWxkQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLllpZWxkQ29tcG9uZW50O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL1JlYWN0UHJpb3JpdHlMZXZlbCcpLFxuICAgIE5vV29yayA9IF9yZXF1aXJlLk5vV29yaztcblxuLy8gQW4gSW5zdGFuY2UgaXMgc2hhcmVkIGJldHdlZW4gYWxsIHZlcnNpb25zIG9mIGEgY29tcG9uZW50LiBXZSBjYW4gZWFzaWx5XG4vLyBicmVhayB0aGlzIG91dCBpbnRvIGEgc2VwYXJhdGUgb2JqZWN0IHRvIGF2b2lkIGNvcHlpbmcgc28gbXVjaCB0byB0aGVcbi8vIGFsdGVybmF0ZSB2ZXJzaW9ucyBvZiB0aGUgdHJlZS4gV2UgcHV0IHRoaXMgb24gYSBzaW5nbGUgb2JqZWN0IGZvciBub3cgdG9cbi8vIG1pbmltaXplIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIuXG5cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cblxuLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIG9mIGEgUE9KTyBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGEgZmV3XG4vLyByZWFzb25zOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNyZWF0ZUZpYmVyIGNhbGwgdG8gY2FsbGluZyBhIGNvbnN0cnVjdG9yIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci4gVGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLlxuLy8gNCkgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5KSB7XG4gIHJldHVybiB7XG5cbiAgICAvLyBJbnN0YW5jZVxuXG4gICAgdGFnOiB0YWcsXG5cbiAgICBrZXk6IGtleSxcblxuICAgIHR5cGU6IG51bGwsXG5cbiAgICBzdGF0ZU5vZGU6IG51bGwsXG5cbiAgICAvLyBGaWJlclxuXG4gICAgJ3JldHVybic6IG51bGwsXG5cbiAgICBjaGlsZDogbnVsbCxcbiAgICBzaWJsaW5nOiBudWxsLFxuXG4gICAgcmVmOiBudWxsLFxuXG4gICAgcGVuZGluZ1Byb3BzOiBudWxsLFxuICAgIG1lbW9pemVkUHJvcHM6IG51bGwsXG4gICAgdXBkYXRlUXVldWU6IG51bGwsXG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgb3V0cHV0OiBudWxsLFxuXG4gICAgbmV4dEVmZmVjdDogbnVsbCxcbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuXG4gICAgcGVuZGluZ1dvcmtQcmlvcml0eTogTm9Xb3JrLFxuICAgIHByb2dyZXNzZWRQcmlvcml0eTogTm9Xb3JrLFxuICAgIHByb2dyZXNzZWRDaGlsZDogbnVsbCxcblxuICAgIGFsdGVybmF0ZTogbnVsbFxuXG4gIH07XG59O1xuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG4vLyBUT0RPOiBSZW5hbWUgdG8gY3JlYXRlV29ya0luUHJvZ3Jlc3NGaWJlciBvciBzb21ldGhpbmcgbGlrZSB0aGF0LlxuZXhwb3J0cy5jbG9uZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyLCBwcmlvcml0eUxldmVsKSB7XG4gIC8vIFdlIGNsb25lIHRvIGdldCBhIHdvcmsgaW4gcHJvZ3Jlc3MuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGZpYmVyIGlzIHRoZVxuICAvLyBjdXJyZW50LiBUbyBtYWtlIGl0IHNhZmUgdG8gcmV1c2UgdGhhdCBmaWJlciBsYXRlciBvbiBhcyB3b3JrIGluIHByb2dyZXNzXG4gIC8vIHdlIG5lZWQgdG8gcmVzZXQgaXRzIHdvcmsgaW4gcHJvZ3Jlc3MgZmxhZyBub3cuIFdlIGRvbid0IGhhdmUgYW5cbiAgLy8gb3Bwb3J0dW5pdHkgdG8gZG8gdGhpcyBlYXJsaWVyIHNpbmNlIHdlIGRvbid0IHRyYXZlcnNlIHRoZSB0cmVlIHdoZW5cbiAgLy8gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MgdHJlZSBiZWNvbWVzIHRoZSBjdXJyZW50IHRyZWUuXG4gIC8vIGZpYmVyLnByb2dyZXNzZWRQcmlvcml0eSA9IE5vV29yaztcbiAgLy8gZmliZXIucHJvZ3Jlc3NlZENoaWxkID0gbnVsbDtcblxuICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsIG9ubHlcbiAgLy8gZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZCBub2RlXG4gIC8vIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nIGV4dHJhXG4gIC8vIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvIHJlY2xhaW0gdGhlXG4gIC8vIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gIHZhciBhbHQgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmIChhbHQpIHtcbiAgICAvLyBXaGVuZXZlciB3ZSBjbG9uZSwgd2UgZG8gc28gdG8gZ2V0IGEgbmV3IHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2UndmUgcmVzZXQgdGhlc2UgaW4gdGhlIG5ldyB0cmVlLlxuICAgIGFsdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBhbHQuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIGFsdC5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHNob3VsZCBub3QgaGF2ZSBhbiBhbHRlcm5hdGUgYWxyZWFkeVxuICAgIGFsdCA9IGNyZWF0ZUZpYmVyKGZpYmVyLnRhZywgZmliZXIua2V5KTtcbiAgICBhbHQudHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgICBhbHQucHJvZ3Jlc3NlZENoaWxkID0gZmliZXIucHJvZ3Jlc3NlZENoaWxkO1xuICAgIGFsdC5wcm9ncmVzc2VkUHJpb3JpdHkgPSBmaWJlci5wcm9ncmVzc2VkUHJpb3JpdHk7XG5cbiAgICBhbHQuYWx0ZXJuYXRlID0gZmliZXI7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gYWx0O1xuICB9XG5cbiAgYWx0LnN0YXRlTm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgYWx0LmNoaWxkID0gZmliZXIuY2hpbGQ7XG4gIGFsdC5zaWJsaW5nID0gZmliZXIuc2libGluZzsgLy8gVGhpcyBzaG91bGQgYWx3YXlzIGJlIG92ZXJyaWRkZW4uIFRPRE86IG51bGxcbiAgYWx0LnJlZiA9IGZpYmVyLnJlZjtcbiAgLy8gcGVuZGluZ1Byb3BzIGlzIGhlcmUgZm9yIHN5bW1ldHJ5IGJ1dCBpcyB1bm5lY2Vzc2FyeSBpbiBwcmFjdGljZSBmb3Igbm93LlxuICAvLyBUT0RPOiBQYXNzIGluIHRoZSBuZXcgcGVuZGluZ1Byb3BzIGFzIGFuIGFyZ3VtZW50IG1heWJlP1xuICBhbHQucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICBhbHQudXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgYWx0LmNhbGxiYWNrTGlzdCA9IGZpYmVyLmNhbGxiYWNrTGlzdDtcbiAgYWx0LnBlbmRpbmdXb3JrUHJpb3JpdHkgPSBwcmlvcml0eUxldmVsO1xuXG4gIGFsdC5tZW1vaXplZFByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgYWx0Lm91dHB1dCA9IGZpYmVyLm91dHB1dDtcblxuICByZXR1cm4gYWx0O1xufTtcblxuZXhwb3J0cy5jcmVhdGVIb3N0Q29udGFpbmVyRmliZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb250YWluZXIsIG51bGwpO1xuICByZXR1cm4gZmliZXI7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcHJpb3JpdHlMZXZlbCkge1xuICAvLyAkRmxvd0ZpeE1lOiBSZWFjdEVsZW1lbnQua2V5IGlzIGN1cnJlbnRseSBkZWZpbmVkIGFzID9zdHJpbmcgYnV0IHNob3VsZCBiZSBkZWZpbmVkIGFzIG51bGwgfCBzdHJpbmcgaW4gRmxvdy5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudFR5cGUoZWxlbWVudC50eXBlLCBlbGVtZW50LmtleSk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIGZpYmVyLnBlbmRpbmdXb3JrUHJpb3JpdHkgPSBwcmlvcml0eUxldmVsO1xuICByZXR1cm4gZmliZXI7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50VHlwZSh0eXBlLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWJlciA9IHNob3VsZENvbnN0cnVjdCh0eXBlKSA/IGNyZWF0ZUZpYmVyKENsYXNzQ29tcG9uZW50LCBrZXkpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5KTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIGtleSk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAvLyBDdXJyZW50bHkgYXNzdW1lZCB0byBiZSBhIGNvbnRpbnVhdGlvbiBhbmQgdGhlcmVmb3JlIGlzIGEgZmliZXIgYWxyZWFkeS5cbiAgICBmaWJlciA9IHR5cGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbXBvbmVudCB0eXBlOiAnICsgdHlwZW9mIHR5cGUpO1xuICB9XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZXhwb3J0cy5jcmVhdGVGaWJlckZyb21FbGVtZW50VHlwZSA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnRUeXBlO1xuXG5leHBvcnRzLmNyZWF0ZUZpYmVyRnJvbUNvcm91dGluZSA9IGZ1bmN0aW9uIChjb3JvdXRpbmUsIHByaW9yaXR5TGV2ZWwpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoQ29yb3V0aW5lQ29tcG9uZW50LCBjb3JvdXRpbmUua2V5KTtcbiAgZmliZXIudHlwZSA9IGNvcm91dGluZS5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3JvdXRpbmU7XG4gIGZpYmVyLnBlbmRpbmdXb3JrUHJpb3JpdHkgPSBwcmlvcml0eUxldmVsO1xuICByZXR1cm4gZmliZXI7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUZpYmVyRnJvbVlpZWxkID0gZnVuY3Rpb24gKHlpZWxkTm9kZSwgcHJpb3JpdHlMZXZlbCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihZaWVsZENvbXBvbmVudCwgeWllbGROb2RlLmtleSk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHt9O1xuICByZXR1cm4gZmliZXI7XG59OyJdfQ==