/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assign = require('object-assign');

var _extends = _assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}

var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

function getRootDisplayNames() {
  return ReactComponentTreeHook.getRootIDs().map(ReactComponentTreeHook.getDisplayName);
}

function getRegisteredDisplayNames() {
  return ReactComponentTreeHook.getRegisteredIDs().map(ReactComponentTreeHook.getDisplayName);
}

function expectTree(rootID, expectedTree, parentPath) {
  var displayName = ReactComponentTreeHook.getDisplayName(rootID);
  var ownerID = ReactComponentTreeHook.getOwnerID(rootID);
  var parentID = ReactComponentTreeHook.getParentID(rootID);
  var childIDs = ReactComponentTreeHook.getChildIDs(rootID);
  var text = ReactComponentTreeHook.getText(rootID);
  var element = ReactComponentTreeHook.getElement(rootID);
  var path = parentPath ? parentPath + ' > ' + displayName : displayName;

  function expectEqual(actual, expected, name) {
    // Get Jasmine to print descriptive error messages.
    // We pass path so that we know where the mismatch occurred.
    expect(_defineProperty({
      path: path
    }, name, actual)).toEqual(_defineProperty({
      path: path
    }, name, expected));
  }

  if (expectedTree.parentDisplayName !== undefined) {
    expectEqual(ReactComponentTreeHook.getDisplayName(parentID), expectedTree.parentDisplayName, 'parentDisplayName');
  }
  if (expectedTree.ownerDisplayName !== undefined) {
    expectEqual(ReactComponentTreeHook.getDisplayName(ownerID), expectedTree.ownerDisplayName, 'ownerDisplayName');
  }
  if (expectedTree.parentID !== undefined) {
    expectEqual(parentID, expectedTree.parentID, 'parentID');
  }
  if (expectedTree.text !== undefined) {
    expectEqual(text, expectedTree.text, 'text');
    expectEqual('' + element, expectedTree.text, 'element.toString()');
  } else {
    expectEqual(text, null, 'text');
  }
  if (expectedTree.element !== undefined) {
    // TODO: Comparing elements makes tests run out of memory on errors.
    // For now, compare just types.
    expectEqual(element && element.type, expectedTree.element && expectedTree.element.type, 'element.type');
  } else if (text == null) {
    expectEqual(typeof element === 'undefined' ? 'undefined' : _typeof(element), 'object', 'typeof element');
  }
  if (expectedTree.children !== undefined) {
    expectEqual(childIDs.length, expectedTree.children.length, 'children.length');
    for (var i = 0; i < childIDs.length; i++) {
      expectTree(childIDs[i], _extends({ parentID: rootID }, expectedTree.children[i]), path);
    }
  } else {
    expectEqual(childIDs, [], 'childIDs');
  }
}

var ReactComponentTreeTestUtils = {
  expectTree: expectTree,
  getRootDisplayNames: getRootDisplayNames,
  getRegisteredDisplayNames: getRegisteredDisplayNames
};

module.exports = ReactComponentTreeTestUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3B1YmxpYy9saWIvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudFRyZWVUZXN0VXRpbHMuanMiXSwibmFtZXMiOlsiX2Fzc2lnbiIsInJlcXVpcmUiLCJfZXh0ZW5kcyIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsImdldFJvb3REaXNwbGF5TmFtZXMiLCJnZXRSb290SURzIiwibWFwIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRSZWdpc3RlcmVkRGlzcGxheU5hbWVzIiwiZ2V0UmVnaXN0ZXJlZElEcyIsImV4cGVjdFRyZWUiLCJyb290SUQiLCJleHBlY3RlZFRyZWUiLCJwYXJlbnRQYXRoIiwiZGlzcGxheU5hbWUiLCJvd25lcklEIiwiZ2V0T3duZXJJRCIsInBhcmVudElEIiwiZ2V0UGFyZW50SUQiLCJjaGlsZElEcyIsImdldENoaWxkSURzIiwidGV4dCIsImdldFRleHQiLCJlbGVtZW50IiwiZ2V0RWxlbWVudCIsInBhdGgiLCJleHBlY3RFcXVhbCIsImFjdHVhbCIsImV4cGVjdGVkIiwibmFtZSIsImV4cGVjdCIsInRvRXF1YWwiLCJwYXJlbnREaXNwbGF5TmFtZSIsInVuZGVmaW5lZCIsIm93bmVyRGlzcGxheU5hbWUiLCJ0eXBlIiwiY2hpbGRyZW4iLCJSZWFjdENvbXBvbmVudFRyZWVUZXN0VXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVVBOzs7O0FBRUEsSUFBSUEsVUFBVUMsUUFBUSxlQUFSLENBQWQ7O0FBRUEsSUFBSUMsV0FBV0YsV0FB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QUNEO0FBQ0Y7O0FBRUQsSUFBSWtCLDhCQUE4QjtBQUNoQzNCLGNBQVlBLFVBRG9CO0FBRWhDTix1QkFBcUJBLG1CQUZXO0FBR2hDSSw2QkFBMkJBO0FBSEssQ0FBbEM7O0FBTUE4QixPQUFPQyxPQUFQLEdBQWlCRiwyQkFBakIiLCJmaWxlIjoiUmVhY3RDb21wb25lbnRUcmVlVGVzdFV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfZXh0ZW5kcyA9IF9hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxuZnVuY3Rpb24gZ2V0Um9vdERpc3BsYXlOYW1lcygpIHtcbiAgcmV0dXJuIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Um9vdElEcygpLm1hcChSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZERpc3BsYXlOYW1lcygpIHtcbiAgcmV0dXJuIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpLm1hcChSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKTtcbn1cblxuZnVuY3Rpb24gZXhwZWN0VHJlZShyb290SUQsIGV4cGVjdGVkVHJlZSwgcGFyZW50UGF0aCkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKHJvb3RJRCk7XG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnRJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQocm9vdElEKTtcbiAgdmFyIGNoaWxkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhyb290SUQpO1xuICB2YXIgdGV4dCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChyb290SUQpO1xuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChyb290SUQpO1xuICB2YXIgcGF0aCA9IHBhcmVudFBhdGggPyBwYXJlbnRQYXRoICsgJyA+ICcgKyBkaXNwbGF5TmFtZSA6IGRpc3BsYXlOYW1lO1xuXG4gIGZ1bmN0aW9uIGV4cGVjdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG5hbWUpIHtcbiAgICAvLyBHZXQgSmFzbWluZSB0byBwcmludCBkZXNjcmlwdGl2ZSBlcnJvciBtZXNzYWdlcy5cbiAgICAvLyBXZSBwYXNzIHBhdGggc28gdGhhdCB3ZSBrbm93IHdoZXJlIHRoZSBtaXNtYXRjaCBvY2N1cnJlZC5cbiAgICBleHBlY3QoX2RlZmluZVByb3BlcnR5KHtcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9LCBuYW1lLCBhY3R1YWwpKS50b0VxdWFsKF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICBwYXRoOiBwYXRoXG4gICAgfSwgbmFtZSwgZXhwZWN0ZWQpKTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZFRyZWUucGFyZW50RGlzcGxheU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4cGVjdEVxdWFsKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUocGFyZW50SUQpLCBleHBlY3RlZFRyZWUucGFyZW50RGlzcGxheU5hbWUsICdwYXJlbnREaXNwbGF5TmFtZScpO1xuICB9XG4gIGlmIChleHBlY3RlZFRyZWUub3duZXJEaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwZWN0RXF1YWwoUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKSwgZXhwZWN0ZWRUcmVlLm93bmVyRGlzcGxheU5hbWUsICdvd25lckRpc3BsYXlOYW1lJyk7XG4gIH1cbiAgaWYgKGV4cGVjdGVkVHJlZS5wYXJlbnRJRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwZWN0RXF1YWwocGFyZW50SUQsIGV4cGVjdGVkVHJlZS5wYXJlbnRJRCwgJ3BhcmVudElEJyk7XG4gIH1cbiAgaWYgKGV4cGVjdGVkVHJlZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHBlY3RFcXVhbCh0ZXh0LCBleHBlY3RlZFRyZWUudGV4dCwgJ3RleHQnKTtcbiAgICBleHBlY3RFcXVhbCgnJyArIGVsZW1lbnQsIGV4cGVjdGVkVHJlZS50ZXh0LCAnZWxlbWVudC50b1N0cmluZygpJyk7XG4gIH0gZWxzZSB7XG4gICAgZXhwZWN0RXF1YWwodGV4dCwgbnVsbCwgJ3RleHQnKTtcbiAgfVxuICBpZiAoZXhwZWN0ZWRUcmVlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IENvbXBhcmluZyBlbGVtZW50cyBtYWtlcyB0ZXN0cyBydW4gb3V0IG9mIG1lbW9yeSBvbiBlcnJvcnMuXG4gICAgLy8gRm9yIG5vdywgY29tcGFyZSBqdXN0IHR5cGVzLlxuICAgIGV4cGVjdEVxdWFsKGVsZW1lbnQgJiYgZWxlbWVudC50eXBlLCBleHBlY3RlZFRyZWUuZWxlbWVudCAmJiBleHBlY3RlZFRyZWUuZWxlbWVudC50eXBlLCAnZWxlbWVudC50eXBlJyk7XG4gIH0gZWxzZSBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgZXhwZWN0RXF1YWwodHlwZW9mIGVsZW1lbnQsICdvYmplY3QnLCAndHlwZW9mIGVsZW1lbnQnKTtcbiAgfVxuICBpZiAoZXhwZWN0ZWRUcmVlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHBlY3RFcXVhbChjaGlsZElEcy5sZW5ndGgsIGV4cGVjdGVkVHJlZS5jaGlsZHJlbi5sZW5ndGgsICdjaGlsZHJlbi5sZW5ndGgnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHBlY3RUcmVlKGNoaWxkSURzW2ldLCBfZXh0ZW5kcyh7IHBhcmVudElEOiByb290SUQgfSwgZXhwZWN0ZWRUcmVlLmNoaWxkcmVuW2ldKSwgcGF0aCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cGVjdEVxdWFsKGNoaWxkSURzLCBbXSwgJ2NoaWxkSURzJyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZVRlc3RVdGlscyA9IHtcbiAgZXhwZWN0VHJlZTogZXhwZWN0VHJlZSxcbiAgZ2V0Um9vdERpc3BsYXlOYW1lczogZ2V0Um9vdERpc3BsYXlOYW1lcyxcbiAgZ2V0UmVnaXN0ZXJlZERpc3BsYXlOYW1lczogZ2V0UmVnaXN0ZXJlZERpc3BsYXlOYW1lc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVUZXN0VXRpbHM7Il19